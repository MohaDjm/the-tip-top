import express, { Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import compression from 'compression';
import rateLimit from 'express-rate-limit';
import { PrismaClient } from '@prisma/client';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import dotenv from 'dotenv';
import Redis from 'ioredis';

dotenv.config();

const app = express();
const prisma = new PrismaClient();
const redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');

// Middleware de s√©curit√©
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3001',
  credentials: true
}));
app.use(compression());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(morgan('combined'));

// Rate limiting pour pr√©venir les abus
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limite de 100 requ√™tes
  message: 'Trop de requ√™tes, veuillez r√©essayer plus tard'
});

app.use('/api/', limiter);

// Middleware d'authentification
interface AuthRequest extends Request {
  user?: any;
}

const authMiddleware = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      return res.status(401).json({ error: 'Token manquant' });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'secret') as any;
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId }
    });

    if (!user) {
      return res.status(401).json({ error: 'Utilisateur non trouv√©' });
    }

    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Token invalide' });
  }
};

// Middleware pour v√©rifier les r√¥les
const roleMiddleware = (roles: string[]) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Acc√®s refus√©' });
    }
    next();
  };
};

// ===========================
// ROUTES D'AUTHENTIFICATION
// ===========================

// Inscription
app.post('/api/auth/register', async (req: Request, res: Response) => {
  try {
    const { email, password, firstName, lastName, phone, address, city, postalCode, dateOfBirth } = req.body;

    // Validation des champs requis
    if (!email || !password || !firstName || !lastName) {
      return res.status(400).json({ error: 'Email, mot de passe, pr√©nom et nom sont requis' });
    }

    // V√©rifier si l'utilisateur existe
    const existingUser = await prisma.user.findUnique({ where: { email } });
    if (existingUser) {
      return res.status(400).json({ error: 'Email d√©j√† utilis√©' });
    }

    // Hasher le mot de passe
    const hashedPassword = await bcrypt.hash(password, 10);

    // Cr√©er l'utilisateur
    const user = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        firstName,
        lastName,
        phone: phone || '',
        address: address || '',
        city: city || '',
        postalCode: postalCode || '',
        dateOfBirth: dateOfBirth ? new Date(dateOfBirth) : new Date('1990-01-01'),
        role: 'CLIENT'
      }
    });

    // G√©n√©rer un token
    const token = jwt.sign(
      { userId: user.id, email: user.email },
      process.env.JWT_SECRET || 'secret',
      { expiresIn: '7d' }
    );

    res.json({ token, user: { id: user.id, email: user.email, firstName: user.firstName, lastName: user.lastName } });
  } catch (error) {
    console.error('Erreur inscription:', error);
    res.status(500).json({ error: 'Erreur lors de l\'inscription', details: error instanceof Error ? error.message : 'Erreur inconnue' });
  }
});

// Connexion
app.post('/api/auth/login', async (req: Request, res: Response) => {
  try {
    console.log('üîê Login attempt:', { email: req.body.email, hasPassword: !!req.body.password });
    
    const { email, password } = req.body;

    if (!email || !password) {
      console.log('‚ùå Missing email or password');
      return res.status(401).json({ error: 'Email et mot de passe requis' });
    }

    // Trouver l'utilisateur
    const user = await prisma.user.findUnique({ where: { email } });
    console.log('üë§ User lookup:', { found: !!user, hasPassword: !!(user?.password) });
    
    if (!user || !user.password) {
      console.log('‚ùå User not found or no password');
      return res.status(401).json({ error: 'Email ou mot de passe incorrect' });
    }

    // V√©rifier le mot de passe
    const validPassword = await bcrypt.compare(password, user.password);
    console.log('üîë Password check:', { valid: validPassword });
    
    if (!validPassword) {
      console.log('‚ùå Invalid password');
      return res.status(401).json({ error: 'Email ou mot de passe incorrect' });
    }

    // G√©n√©rer un token
    const token = jwt.sign(
      { userId: user.id, email: user.email },
      process.env.JWT_SECRET || 'secret',
      { expiresIn: '7d' }
    );

    console.log('‚úÖ Login successful for:', user.email);
    res.json({ token, user: { id: user.id, email: user.email, firstName: user.firstName, lastName: user.lastName, role: user.role } });
  } catch (error) {
    console.error('Erreur connexion:', error);
    res.status(500).json({ error: 'Erreur lors de la connexion' });
  }
});

// SSO Google/Facebook (endpoint √† int√©grer avec NextAuth)
app.post('/api/auth/social', async (req: Request, res: Response) => {
  try {
    const { provider, providerAccountId, email, firstName, lastName } = req.body;

    // V√©rifier si le compte social existe
    let socialAccount = await prisma.socialAccount.findUnique({
      where: {
        provider_providerAccountId: {
          provider,
          providerAccountId
        }
      },
      include: { user: true }
    });

    let user;
    if (socialAccount) {
      user = socialAccount.user;
    } else {
      // Cr√©er un nouvel utilisateur
      user = await prisma.user.create({
        data: {
          email,
          firstName,
          lastName,
          dateOfBirth: new Date(), // √Ä compl√©ter par l'utilisateur plus tard
          phone: '', // √Ä compl√©ter
          address: '', // √Ä compl√©ter
          city: '', // √Ä compl√©ter
          postalCode: '', // √Ä compl√©ter
          socialAccounts: {
            create: {
              provider,
              providerAccountId
            }
          }
        }
      });
    }

    const token = jwt.sign(
      { userId: user.id, email: user.email },
      process.env.JWT_SECRET || 'secret',
      { expiresIn: '7d' }
    );

    res.json({ token, user: { id: user.id, email: user.email, firstName: user.firstName, lastName: user.lastName } });
  } catch (error) {
    console.error('Erreur auth sociale:', error);
    res.status(500).json({ error: 'Erreur lors de l\'authentification sociale' });
  }
});

// ===========================
// ROUTES DE PARTICIPATION
// ===========================

// V√©rifier un code sans le marquer comme utilis√© (pour la roue)
app.post('/api/participation/check-code', authMiddleware, async (req: AuthRequest, res: Response) => {
  try {
    const { code } = req.body;

    // V√©rifier le format du code (10 caract√®res alphanum√©riques)
    if (!/^[A-Z0-9]{10}$/.test(code)) {
      return res.status(400).json({ error: 'Format de code invalide' });
    }

    // V√©rifier dans la base de donn√©es
    const codeEntry = await prisma.code.findUnique({
      where: { code },
      include: { gain: true }
    });

    if (!codeEntry) {
      return res.status(404).json({ error: 'Code invalide' });
    }

    if (codeEntry.isUsed) {
      return res.status(400).json({ error: 'Ce code a d√©j√† √©t√© utilis√©' });
    }

    // Retourner le gain sans marquer le code comme utilis√©
    res.json({
      valid: true,
      gain: {
        name: codeEntry.gain.name,
        value: codeEntry.gain.value,
        description: codeEntry.gain.description
      }
    });
  } catch (error) {
    console.error('Erreur v√©rification code:', error);
    res.status(500).json({ error: 'Erreur lors de la v√©rification du code' });
  }
});

// Marquer un code comme utilis√© apr√®s animation (claim)
app.post('/api/participation/claim', authMiddleware, async (req: AuthRequest, res: Response) => {
  try {
    const { code } = req.body;
    const userId = req.user.id;

    // V√©rifier le format du code (10 caract√®res alphanum√©riques)
    if (!/^[A-Z0-9]{10}$/.test(code)) {
      return res.status(400).json({ error: 'Format de code invalide' });
    }

    // V√©rifier dans la base de donn√©es
    const codeEntry = await prisma.code.findUnique({
      where: { code },
      include: { gain: true }
    });

    if (!codeEntry) {
      return res.status(404).json({ error: 'Code invalide' });
    }

    if (codeEntry.isUsed) {
      return res.status(400).json({ error: 'Ce code a d√©j√† √©t√© utilis√©' });
    }

    // Cr√©er la participation dans une transaction
    const participation = await prisma.$transaction(async (tx) => {
      // Marquer le code comme utilis√©
      await tx.code.update({
        where: { id: codeEntry.id },
        data: { isUsed: true }
      });

      // Cr√©er la participation
      const newParticipation = await tx.participation.create({
        data: {
          userId,
          codeId: codeEntry.id,
          gainId: codeEntry.gainId,
          ipAddress: req.ip || 'unknown',
          userAgent: req.headers['user-agent'] || 'unknown'
        },
        include: { gain: true }
      });

      // D√©cr√©menter le stock de gains restants
      await tx.gain.update({
        where: { id: codeEntry.gainId },
        data: { remainingQuantity: { decrement: 1 } }
      });

      return newParticipation;
    });

    res.json({
      success: true,
      participation: {
        id: participation.id,
        gain: {
          name: participation.gain.name,
          value: participation.gain.value,
          description: participation.gain.description
        },
        participationDate: participation.participationDate
      }
    });
  } catch (error) {
    console.error('Erreur claim code:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©clamation du gain' });
  }
});

// Valider un code et participer (DEPRECATED - utiliser check-code + claim)
app.post('/api/participation/validate', authMiddleware, async (req: AuthRequest, res: Response) => {
  try {
    const { code } = req.body;
    const userId = req.user.id;

    // V√©rifier le format du code (10 caract√®res alphanum√©riques)
    if (!/^[A-Z0-9]{10}$/.test(code)) {
      return res.status(400).json({ error: 'Format de code invalide' });
    }

    // V√©rifier dans le cache Redis d'abord
    const cachedResult = await redis.get(`code:${code}`);
    if (cachedResult === 'used') {
      return res.status(400).json({ error: 'Ce code a d√©j√† √©t√© utilis√©' });
    }

    // V√©rifier dans la base de donn√©es
    const codeEntry = await prisma.code.findUnique({
      where: { code },
      include: { gain: true }
    });

    if (!codeEntry) {
      return res.status(404).json({ error: 'Code invalide' });
    }

    if (codeEntry.isUsed) {
      // Mettre en cache pour les futures v√©rifications
      await redis.set(`code:${code}`, 'used', 'EX', 3600);
      return res.status(400).json({ error: 'Ce code a d√©j√† √©t√© utilis√©' });
    }

    // Cr√©er la participation dans une transaction
    const participation = await prisma.$transaction(async (tx) => {
      // Marquer le code comme utilis√©
      await tx.code.update({
        where: { id: codeEntry.id },
        data: { isUsed: true }
      });

      // Cr√©er la participation
      const newParticipation = await tx.participation.create({
        data: {
          userId,
          codeId: codeEntry.id,
          gainId: codeEntry.gainId,
          ipAddress: req.ip || 'unknown',
          userAgent: req.headers['user-agent'] || 'unknown'
        },
        include: { gain: true }
      });

      // D√©cr√©menter le stock de gains restants
      await tx.gain.update({
        where: { id: codeEntry.gainId },
        data: { remainingQuantity: { decrement: 1 } }
      });

      return newParticipation;
    });

    // Mettre en cache le code utilis√©
    await redis.set(`code:${code}`, 'used', 'EX', 3600);

    // Envoyer un email de confirmation (√† impl√©menter)
    // await sendConfirmationEmail(req.user.email, participation.gain);

    res.json({
      success: true,
      gain: {
        name: participation.gain.name,
        value: participation.gain.value,
        description: participation.gain.description
      },
      participationId: participation.id
    });
  } catch (error) {
    console.error('Erreur validation code:', error);
    res.status(500).json({ error: 'Erreur lors de la validation du code' });
  }
});

// R√©cup√©rer l'historique des participations
app.get('/api/participation/history', authMiddleware, async (req: AuthRequest, res: Response) => {
  try {
    const participations = await prisma.participation.findMany({
      where: { userId: req.user.id },
      include: { gain: true, code: true },
      orderBy: { participationDate: 'desc' }
    });

    res.json(participations);
  } catch (error) {
    console.error('Erreur r√©cup√©ration historique:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration de l\'historique' });
  }
});

// ===========================
// ROUTES POUR LES CAISSES
// ===========================

// Endpoint pour les caisses - V√©rifier si un code est valide
app.post('/api/caisse/verify-code', async (req: Request, res: Response) => {
  try {
    const { code, apiKey } = req.body;

    // V√©rifier l'API key des caisses
    if (apiKey !== process.env.CAISSE_API_KEY) {
      return res.status(401).json({ error: 'API key invalide' });
    }

    const codeEntry = await prisma.code.findUnique({
      where: { code },
      include: { gain: true }
    });

    if (!codeEntry) {
      return res.json({ valid: false, message: 'Code invalide' });
    }

    if (codeEntry.isUsed) {
      return res.json({ valid: false, message: 'Code d√©j√† utilis√©' });
    }

    res.json({
      valid: true,
      gain: {
        name: codeEntry.gain.name,
        value: codeEntry.gain.value
      }
    });
  } catch (error) {
    console.error('Erreur v√©rification code caisse:', error);
    res.status(500).json({ error: 'Erreur lors de la v√©rification' });
  }
});

// ===========================
// ROUTES EMPLOY√âS
// ===========================

// Rechercher un gain client
app.post('/api/employee/search-gain', authMiddleware, roleMiddleware(['EMPLOYEE', 'ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    const { searchTerm } = req.body;

    // Rechercher par code ou email
    let participation;
    
    // Si c'est un code (10 caract√®res)
    if (/^[A-Z0-9]{10}$/.test(searchTerm)) {
      participation = await prisma.participation.findFirst({
        where: {
          code: { code: searchTerm }
        },
        include: {
          user: true,
          gain: true,
          code: true
        }
      });
    } else {
      // Sinon rechercher par email
      participation = await prisma.participation.findFirst({
        where: {
          user: { email: searchTerm },
          isClaimed: false
        },
        include: {
          user: true,
          gain: true,
          code: true
        },
        orderBy: { participationDate: 'desc' }
      });
    }

    if (!participation) {
      return res.status(404).json({ error: 'Aucun gain trouv√©' });
    }

    res.json({
      participationId: participation.id,
      client: {
        name: `${participation.user.firstName} ${participation.user.lastName}`,
        email: participation.user.email
      },
      gain: {
        name: participation.gain.name,
        value: participation.gain.value
      },
      code: participation.code.code,
      isClaimed: participation.isClaimed,
      claimedAt: participation.claimedAt
    });
  } catch (error) {
    console.error('Erreur recherche gain:', error);
    res.status(500).json({ error: 'Erreur lors de la recherche' });
  }
});

// Marquer un gain comme remis
app.post('/api/employee/mark-claimed', authMiddleware, roleMiddleware(['EMPLOYEE', 'ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    const { participationId } = req.body;

    const participation = await prisma.participation.update({
      where: { id: participationId },
      data: {
        isClaimed: true,
        claimedAt: new Date(),
        claimedByEmployeeId: req.user.id
      }
    });

    res.json({ success: true, participation });
  } catch (error) {
    console.error('Erreur marquage gain:', error);
    res.status(500).json({ error: 'Erreur lors du marquage' });
  }
});

// ===========================
// ROUTES ADMINISTRATION
// ===========================

// Statistiques g√©n√©rales
app.get('/api/admin/stats', authMiddleware, roleMiddleware(['ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    // Statistiques globales
    const totalCodes = await prisma.code.count();
    const usedCodes = await prisma.code.count({ where: { isUsed: true } });
    const totalParticipations = await prisma.participation.count();
    const claimedGains = await prisma.participation.count({ where: { isClaimed: true } });

    // Statistiques par gain
    const gainStats = await prisma.gain.findMany({
      include: {
        _count: {
          select: { participations: true }
        }
      }
    });

    // D√©mographie (gestion des cas o√π il n'y a pas de participations)
    let ageGroups: any[] = [];
    try {
      if (totalParticipations > 0) {
        const rawAgeGroups = await prisma.$queryRaw`
          SELECT 
            CASE 
              WHEN EXTRACT(YEAR FROM AGE(NOW(), "dateOfBirth")) < 25 THEN '18-25'
              WHEN EXTRACT(YEAR FROM AGE(NOW(), "dateOfBirth")) < 35 THEN '26-35'
              WHEN EXTRACT(YEAR FROM AGE(NOW(), "dateOfBirth")) < 45 THEN '36-45'
              WHEN EXTRACT(YEAR FROM AGE(NOW(), "dateOfBirth")) < 60 THEN '46-60'
              ELSE '60+'
            END as age_group,
            COUNT(*) as count
          FROM "User"
          JOIN "Participation" ON "User".id = "Participation"."userId"
          GROUP BY age_group
        ` as any[];
        
        // Convertir BigInt en Number pour √©viter l'erreur de s√©rialisation
        ageGroups = rawAgeGroups.map(group => ({
          age_group: group.age_group,
          count: Number(group.count)
        }));
      }
    } catch (demographicsError) {
      console.warn('Erreur d√©mographie (ignor√©e):', demographicsError);
      ageGroups = [];
    }

    res.json({
      global: {
        totalCodes,
        usedCodes,
        participationRate: totalCodes > 0 ? ((usedCodes / totalCodes) * 100).toFixed(2) : '0.00',
        totalParticipations,
        claimedGains
      },
      gains: gainStats.map(gain => ({
        name: gain.name,
        totalQuantity: gain.quantity,
        distributed: gain._count.participations,
        remaining: gain.remainingQuantity,
        percentage: gain.quantity > 0 ? ((gain._count.participations / gain.quantity) * 100).toFixed(2) : '0.00'
      })),
      demographics: {
        ageGroups
      }
    });
  } catch (error) {
    console.error('Erreur statistiques:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des statistiques' });
  }
});

// Participations r√©centes pour admin
app.get('/api/admin/recent-participations', authMiddleware, roleMiddleware(['ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    const recentParticipations = await prisma.participation.findMany({
      take: 50,
      orderBy: { participationDate: 'desc' },
      include: {
        user: {
          select: { firstName: true, lastName: true, email: true }
        },
        code: {
          select: { code: true }
        },
        gain: {
          select: { name: true, value: true }
        }
      }
    });

    res.json(recentParticipations);
  } catch (error) {
    console.error('Erreur participations r√©centes:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des participations r√©centes' });
  }
});

// Gains pour admin
app.get('/api/admin/gains', authMiddleware, roleMiddleware(['ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    const gains = await prisma.gain.findMany({
      include: {
        _count: {
          select: { participations: true }
        }
      }
    });

    // Enrichir les donn√©es avec les informations de codes
    const enrichedGains = await Promise.all(gains.map(async (gain) => {
      const totalCodes = await prisma.code.count({ where: { gainId: gain.id } });
      const usedCodes = await prisma.code.count({ where: { gainId: gain.id, isUsed: true } });
      
      return {
        ...gain,
        totalCodes,
        usedCodes,
        distributed: gain._count.participations,
        remaining: gain.remainingQuantity
      };
    }));

    res.json(enrichedGains);
  } catch (error) {
    console.error('Erreur gains:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des gains' });
  }
});

// Toutes les participations pour admin
app.get('/api/admin/participations', authMiddleware, roleMiddleware(['ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    const participations = await prisma.participation.findMany({
      include: {
        user: {
          select: { firstName: true, lastName: true, email: true }
        },
        code: {
          select: { code: true }
        },
        gain: {
          select: { name: true, value: true }
        }
      },
      orderBy: { participationDate: 'desc' }
    });

    res.json(participations);
  } catch (error) {
    console.error('Erreur participations:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des participations' });
  }
});

// Utilisateurs pour admin
app.get('/api/admin/users', authMiddleware, roleMiddleware(['ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    const users = await prisma.user.findMany({
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        role: true,
        createdAt: true,
        _count: {
          select: { participations: true }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    res.json(users);
  } catch (error) {
    console.error('Erreur utilisateurs:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des utilisateurs' });
  }
});

// Stats pour employ√©
app.get('/api/employee/stats', authMiddleware, roleMiddleware(['EMPLOYEE', 'ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    const totalParticipations = await prisma.participation.count();
    const claimedGains = await prisma.participation.count({ where: { isClaimed: true } });
    const unclaimedGains = await prisma.participation.count({ where: { isClaimed: false } });

    res.json({
      totalParticipations,
      claimedGains,
      unclaimedGains
    });
  } catch (error) {
    console.error('Erreur stats employ√©:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des statistiques' });
  }
});

// Prix non r√©clam√©s pour employ√©
app.get('/api/employee/unclaimed-prizes', authMiddleware, roleMiddleware(['EMPLOYEE', 'ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    const unclaimedPrizes = await prisma.participation.findMany({
      where: { isClaimed: false },
      include: {
        user: {
          select: { firstName: true, lastName: true, email: true }
        },
        gain: {
          select: { name: true, value: true }
        }
      },
      orderBy: { participationDate: 'desc' }
    });

    res.json(unclaimedPrizes);
  } catch (error) {
    console.error('Erreur prix non r√©clam√©s:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des prix non r√©clam√©s' });
  }
});

// Prix r√©clam√©s pour employ√©
app.get('/api/employee/claimed-prizes', authMiddleware, roleMiddleware(['EMPLOYEE', 'ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    const claimedPrizes = await prisma.participation.findMany({
      where: { isClaimed: true },
      include: {
        user: {
          select: { firstName: true, lastName: true, email: true }
        },
        gain: {
          select: { name: true, value: true }
        }
      },
      orderBy: { claimedAt: 'desc' }
    });

    res.json(claimedPrizes);
  } catch (error) {
    console.error('Erreur prix r√©clam√©s:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des prix r√©clam√©s' });
  }
});

// R√©clamer un prix (employ√©)
app.post('/api/employee/claim-prize/:participationId', authMiddleware, roleMiddleware(['EMPLOYEE', 'ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    const { participationId } = req.params;

    const participation = await prisma.participation.update({
      where: { id: participationId },
      data: { 
        isClaimed: true,
        claimedAt: new Date()
      },
      include: {
        user: {
          select: { firstName: true, lastName: true, email: true }
        },
        gain: {
          select: { name: true, value: true }
        }
      }
    });

    res.json(participation);
  } catch (error) {
    console.error('Erreur r√©clamation prix:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©clamation du prix' });
  }
});

// Export des emails pour campagne marketing
app.get('/api/admin/export-emails', authMiddleware, roleMiddleware(['ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    const users = await prisma.user.findMany({
      where: {
        participations: {
          some: {}
        }
      },
      select: {
        email: true,
        firstName: true,
        lastName: true,
        createdAt: true,
        _count: {
          select: { participations: true }
        }
      }
    });

    // Format CSV
    const csv = 'Email,Pr√©nom,Nom,Date inscription,Participations\n' + 
      users.map(u => 
        `${u.email},${u.firstName},${u.lastName},${u.createdAt.toISOString()},${u._count.participations}`
      ).join('\n');

    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename="export_emails.csv"');
    res.send(csv);
  } catch (error) {
    console.error('Erreur export emails:', error);
    res.status(500).json({ error: 'Erreur lors de l\'export' });
  }
});

// ===========================
// TIRAGE AU SORT FINAL
// ===========================

app.post('/api/admin/grand-tirage', authMiddleware, roleMiddleware(['ADMIN']), async (req: AuthRequest, res: Response) => {
  try {
    // R√©cup√©rer tous les participants uniques
    const participants = await prisma.user.findMany({
      where: {
        participations: {
          some: {}
        }
      }
    });

    if (participants.length === 0) {
      return res.status(400).json({ error: 'Aucun participant au tirage' });
    }

    // S√©lectionner un gagnant al√©atoirement
    const winnerIndex = Math.floor(Math.random() * participants.length);
    const winner = participants[winnerIndex];

    // Enregistrer le r√©sultat (√† cr√©er une table sp√©cifique si n√©cessaire)
    
    res.json({
      winner: {
        id: winner.id,
        name: `${winner.firstName} ${winner.lastName}`,
        email: winner.email
      },
      totalParticipants: participants.length,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Erreur tirage au sort:', error);
    res.status(500).json({ error: 'Erreur lors du tirage au sort' });
  }
});

// Health check pour le monitoring
app.get('/api/health', async (req: Request, res: Response) => {
  try {
    await prisma.$queryRaw`SELECT 1`;
    await redis.ping();
    res.json({ status: 'OK', timestamp: new Date().toISOString() });
  } catch (error) {
    res.status(500).json({ status: 'ERROR', error: error });
  }
});

// D√©marrage du serveur
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`üöÄ API d√©marr√©e sur le port ${PORT}`);
  console.log(`üìä Environnement: ${process.env.NODE_ENV || 'development'}`);
});